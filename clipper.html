<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <meta name="color-scheme" content="dark" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b0b0f;
        --surface: #16161c;
        --surface-2: #1f1f26;
        --border: #2a2a34;
        --text: #f2f2f7;
        --muted: #8e8e93;
        --accent: #7c5cff;
        --positive: #2ecc71;
        --warning: #f7b731;
        --danger: #ff5d6c;
        --glow: rgba(124, 92, 255, 0.22);
        --shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
        --radius-lg: 22px;
        --radius-md: 16px;
        --radius-sm: 12px;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          system-ui, sans-serif;
        background: var(--bg);
        color: var(--text);
        overscroll-behavior: none;
        -webkit-font-smoothing: antialiased;
        scrollbar-width: none;
      }

      body::-webkit-scrollbar {
        display: none;
      }

      body {
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
          env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      img {
        display: block;
        max-width: 100%;
      }

      button,
      input,
      select {
        font: inherit;
        color: inherit;
        border: none;
        background: none;
      }

      input:focus,
      select:focus,
      button:focus-visible {
        outline: 2px solid rgba(124, 92, 255, 0.6);
        outline-offset: 2px;
      }

      .app {
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
      }

      .container {
        width: min(100%, 480px);
        margin: 0 auto;
        padding: 24px 18px 120px;
        display: flex;
        flex-direction: column;
        gap: 22px;
      }

      .hero {
        text-align: center;
        padding-top: 10px;
      }

      .hero h1 {
        margin: 0;
        font-size: 30px;
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      .hero p {
        margin: 8px 0 0;
        color: var(--muted);
        font-size: 13px;
      }

      .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow);
      }

      .card-inner {
        padding: 16px;
      }

      .input-wrap {
        position: relative;
      }

      .input {
        width: 100%;
        height: 56px;
        padding: 0 54px 0 44px;
        border-radius: var(--radius-lg);
        background: var(--surface);
        border: 1px solid var(--border);
        color: var(--text);
      }

      .input::placeholder {
        color: var(--muted);
      }

      .input-icon {
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        color: var(--muted);
      }

      .clear-btn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        background: var(--surface-2);
      }

      .primary-btn {
        width: 100%;
        height: 56px;
        border-radius: var(--radius-lg);
        background: var(--accent);
        color: white;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        transition: transform 0.08s ease, opacity 0.2s ease;
      }

      .primary-btn:active {
        transform: scale(0.98);
      }

      .secondary-btn {
        width: 100%;
        height: 52px;
        border-radius: var(--radius-lg);
        background: var(--surface);
        border: 1px solid var(--border);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .pill-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .pill {
        padding: 8px 14px;
        border-radius: 999px;
        background: var(--surface-2);
        border: 1px solid var(--border);
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .pill.active {
        color: white;
        background: linear-gradient(135deg, #7c5cff, #5b7cfa);
        border-color: transparent;
        box-shadow: 0 8px 24px rgba(124, 92, 255, 0.32);
      }

      .top-widget {
        display: grid;
        gap: 12px;
      }

      .top-widget-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .top-widget-title {
        font-weight: 700;
        font-size: 16px;
      }

      .country-select {
        background: var(--surface-2);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 8px 12px;
        font-weight: 600;
        font-size: 12px;
        color: var(--text);
      }

      .video-strip {
        display: grid;
        gap: 10px;
      }

      .video-card {
        display: grid;
        grid-template-columns: 90px 1fr;
        gap: 12px;
        padding: 12px;
        border-radius: var(--radius-md);
        background: var(--surface-2);
        border: 1px solid var(--border);
      }

      .video-cover {
        width: 90px;
        height: 64px;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
      }

      .video-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-cover span {
        position: absolute;
        bottom: 6px;
        right: 6px;
        background: rgba(0, 0, 0, 0.65);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 10px;
        font-weight: 600;
      }

      .video-info h4 {
        margin: 0 0 6px;
        font-size: 13px;
      }

      .video-meta {
        font-size: 11px;
        color: var(--muted);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .section-title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .section-title h2 {
        margin: 0;
        font-size: 16px;
      }

      .badge {
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(124, 92, 255, 0.16);
        color: #c3b6ff;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .progress {
        display: grid;
        gap: 8px;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        border-radius: 999px;
        background: var(--surface-2);
        overflow: hidden;
        border: 1px solid var(--border);
      }

      .progress-fill {
        height: 100%;
        border-radius: inherit;
        transition: width 0.2s ease;
      }

      .error {
        border: 1px solid rgba(255, 93, 108, 0.35);
        background: rgba(255, 93, 108, 0.08);
        color: #ffd2d7;
        padding: 14px;
        border-radius: var(--radius-md);
        font-size: 13px;
      }

      .video-wrap {
        background: #000;
        border-radius: var(--radius-lg);
        overflow: hidden;
        position: relative;
        min-height: 48dvh;
        border: 1px solid var(--border);
      }

      video {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
      }

      .overlay-chip {
        position: absolute;
        top: 12px;
        left: 12px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 700;
      }

      .overlay-chip.right {
        left: auto;
        right: 12px;
      }

      .stats-grid {
        display: grid;
        gap: 10px;
      }

      .stats-row {
        display: grid;
        gap: 10px;
      }

      .stat {
        text-align: center;
        padding: 10px;
        border-radius: 14px;
        background: var(--surface-2);
        border: 1px solid var(--border);
      }

      .stat h4 {
        margin: 6px 0 0;
        font-size: 14px;
      }

      .stat p {
        margin: 2px 0 0;
        font-size: 10px;
        color: var(--muted);
      }

      .history-strip {
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding-bottom: 6px;
        scrollbar-width: none;
      }

      .history-strip::-webkit-scrollbar {
        display: none;
      }

      .history-card {
        width: 90px;
        flex: 0 0 auto;
      }

      .history-thumb {
        width: 90px;
        height: 120px;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid var(--border);
        position: relative;
      }

      .history-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .history-thumb span {
        position: absolute;
        bottom: 6px;
        right: 6px;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 9px;
      }

      .sponsor-grid {
        display: grid;
        gap: 10px;
      }

      .sponsor-card {
        display: grid;
        grid-template-columns: 56px 1fr;
        gap: 12px;
        padding: 12px;
        border-radius: var(--radius-md);
        border: 1px solid var(--border);
        background: var(--surface-2);
        align-items: center;
      }

      .sponsor-card img {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 2px solid var(--border);
        object-fit: cover;
      }

      .sponsor-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .ghost-btn {
        padding: 8px 10px;
        border-radius: 10px;
        background: transparent;
        border: 1px solid var(--border);
        font-size: 12px;
        font-weight: 600;
      }

      .success {
        color: var(--positive);
        font-weight: 700;
      }

      .footer {
        text-align: center;
        color: var(--muted);
        font-size: 12px;
        padding-top: 8px;
      }

      .fade {
        animation: fadeIn 0.4s ease both;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "alpinejs": "https://cdn.jsdelivr.net/npm/alpinejs@3.15.3/+esm"
        }
      }
    </script>
  </head>

  <body class="app" x-data="ClipperApp" x-init="init()">
    <main class="container">
      <header class="hero fade">
        <h1>Clipper</h1>
        <p x-text="statusText"></p>
      </header>

      <section class="card fade">
        <div class="card-inner top-widget">
          <div class="top-widget-header">
            <div class="section-title">
              <h2>В топе</h2>
              <span class="badge">Live</span>
            </div>
            <select
              class="country-select"
              x-model="topCountry"
              @change="updateTopVideos()"
            >
              <template x-for="country in topCountries" :key="country.code">
                <option :value="country.code" x-text="country.name"></option>
              </template>
            </select>
          </div>

          <div class="pill-group">
            <template x-for="p in PlatformRegistry.all()" :key="p.name">
              <button
                class="pill"
                :class="{ active: topPlatform === p.name }"
                @click="selectTopPlatform(p.name)"
                type="button"
              >
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  :style="{ color: p.colors?.icon || '#fff' }"
                >
                  <path :d="p.icon" />
                </svg>
                <span x-text="p.name"></span>
              </button>
            </template>
          </div>

          <div class="video-strip">
            <template x-for="video in topVideos" :key="video.id">
              <article class="video-card">
                <div class="video-cover">
                  <img :src="video.cover" :alt="video.title" loading="lazy" />
                  <span x-text="video.duration"></span>
                </div>
                <div class="video-info">
                  <h4 x-text="video.title"></h4>
                  <div class="video-meta">
                    <span x-text="video.author"></span>
                    <span x-text="video.views + ' просмотров'"></span>
                  </div>
                </div>
              </article>
            </template>
          </div>
        </div>
      </section>

      <section class="fade">
        <div class="input-wrap">
          <div class="input-icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
              <path
                d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </div>
          <input
            class="input"
            type="url"
            x-model="url"
            placeholder="Вставьте ссылку на видео"
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            @input.debounce.300ms="detect()"
            @keydown.enter.prevent="download"
            :disabled="isLoading"
          />
          <button
            x-show="url.length"
            class="clear-btn"
            @click="clear"
            type="button"
            aria-label="Очистить"
          >
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
              <path
                d="M6 18L18 6M6 6l12 12"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>

        <button
          x-show="platform && !isLoading && !video"
          class="primary-btn"
          @click="download"
          type="button"
          :style="{ background: platform?.colors?.primary || 'var(--accent)' }"
        >
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
            <path
              d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Сохранить видео</span>
        </button>
      </section>

      <section class="fade" x-show="isLoading">
        <div class="card">
          <div class="card-inner progress">
            <div class="section-title">
              <h2>Загрузка</h2>
              <span x-text="progress + '%'"></span>
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                :style="{ width: progress + '%', background: platform?.colors?.progress || 'var(--accent)' }"
              ></div>
            </div>
            <p class="footer" x-text="loadingText"></p>
          </div>
        </div>
      </section>

      <section class="fade" x-show="error && !isLoading">
        <div class="error" x-text="error"></div>
      </section>

      <section class="fade" x-show="video && !isLoading">
        <div class="video-wrap">
          <video
            :src="currentVideoUrl"
            :poster="video.cover"
            controls
            playsinline
          ></video>
          <div class="overlay-chip">
            <svg
              width="14"
              height="14"
              viewBox="0 0 24 24"
              fill="currentColor"
              :style="{ color: platform?.colors?.icon }"
            >
              <path :d="platform?.icon" />
            </svg>
            <span x-text="platform?.name"></span>
          </div>
          <div class="overlay-chip right" style="top: 12px">
            <span x-text="NumberFormatter.formatDuration(video.duration)"></span>
          </div>
          <div class="overlay-chip right" style="top: 44px">
            <span x-text="currentQualityLabel"></span>
          </div>
        </div>

        <div
          class="pill-group"
          x-show="hasMultipleQualities && !isChangingQuality"
        >
          <template x-for="q in availableQualities" :key="q.key">
            <button
              class="pill"
              :class="{ active: selectedQuality === q.key }"
              @click="selectQuality(q.key)"
              type="button"
            >
              <span x-text="q.label"></span>
            </button>
          </template>
        </div>

        <div class="card" x-show="video?.author">
          <div class="card-inner sponsor-card">
            <img
              :src="video.author?.avatar"
              :alt="video.author?.nickname"
              @error="if ($event.target.src !== AppAssets.avatar) $event.target.src = AppAssets.avatar"
            />
            <div>
              <div x-text="video.author?.nickname || 'Неизвестный автор'"></div>
              <div class="footer" x-text="video.author?.unique_id ? '@' + video.author.unique_id : ''"></div>
            </div>
            <button class="ghost-btn" @click="openAuthorProfile" type="button">
              Профиль
            </button>
          </div>
        </div>

        <div class="stats-grid" x-show="visibleStats.length">
          <div
            class="stats-row"
            :style="{ gridTemplateColumns: 'repeat(' + visibleStats.length + ', minmax(0,1fr))' }"
          >
            <template x-for="stat in visibleStats" :key="stat.key">
              <div class="stat">
                <svg
                  width="18"
                  height="18"
                  viewBox="0 0 24 24"
                  fill="none"
                  :style="{ color: platform?.colors?.statsIcon }"
                >
                  <path
                    :d="stat.icon"
                    stroke="currentColor"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
                <h4 x-text="NumberFormatter.formatCompact(video[stat.key])"></h4>
                <p x-text="stat.label"></p>
              </div>
            </template>
          </div>
        </div>

        <div class="pill-group">
          <button
            class="primary-btn"
            @click="saveVideo"
            :disabled="!currentVideoUrl || isSaving"
            :style="{ background: platform?.colors?.save || 'var(--accent)' }"
            type="button"
          >
            Сохранить
          </button>
          <button
            class="primary-btn"
            @click="shareStory"
            :disabled="!currentVideoUrl"
            :style="{ background: platform?.colors?.story || '#f7f7f7', color: '#111' }"
            type="button"
          >
            В историю
          </button>
        </div>

        <button
          class="secondary-btn"
          @click="shareLink"
          :disabled="!video || !platform"
          type="button"
        >
          Поделиться ссылкой
        </button>
      </section>

      <section class="fade" x-show="!isLoading && !video">
        <div class="section-title">
          <h2>Спонсоры</h2>
          <span class="badge" x-text="unconfirmedSponsors.length + ' осталось'"></span>
        </div>
        <p class="footer">
          Для доступа к загрузке откройте каналы и подтвердите подписку
        </p>

        <div class="sponsor-grid">
          <template x-for="sponsor in sponsorsList" :key="sponsor.username">
            <div class="sponsor-card">
              <img
                :src="sponsor.photo"
                :alt="sponsor.title"
                @error="if ($event.target.src !== AppAssets.sponsor) $event.target.src = AppAssets.sponsor"
              />
              <div>
                <div x-text="sponsor.title"></div>
                <div class="footer" x-text="'@' + sponsor.username"></div>
                <div class="sponsor-actions">
                  <button
                    class="ghost-btn"
                    @click="openSponsor(sponsor.username)"
                    type="button"
                  >
                    Открыть
                  </button>
                  <button
                    class="ghost-btn"
                    @click="confirmSponsor(sponsor.username)"
                    type="button"
                    :disabled="!canConfirmSponsor(sponsor.username)"
                  >
                    Я подписался
                  </button>
                </div>
              </div>
              <div class="success" x-show="isSponsorConfirmed(sponsor.username)">
                ✓
              </div>
            </div>
          </template>
        </div>
      </section>

      <section class="fade" x-show="!isLoading && !video">
        <div class="section-title">
          <h2>Недавние видео</h2>
          <button class="ghost-btn" x-show="history.length" @click="clearHistory" type="button">
            Очистить
          </button>
        </div>

        <div x-show="history.length === 0" class="card">
          <div class="card-inner">
            <p>История пуста</p>
            <p class="footer">Сохраните видео, чтобы оно появилось здесь</p>
          </div>
        </div>

        <div class="history-strip" x-show="history.length > 0">
          <template x-for="item in history" :key="item.id">
            <button class="history-card" @click="loadFromHistory(item)" type="button">
              <div class="history-thumb">
                <img
                  :src="item.cover"
                  @error="if ($event.target.src !== AppAssets.cover) $event.target.src = AppAssets.cover"
                  loading="lazy"
                />
                <span x-text="item.quality?.toUpperCase()"></span>
              </div>
              <p class="footer" x-text="item.author"></p>
            </button>
          </template>
        </div>
      </section>

      <footer class="footer fade" x-show="!isLoading && !video">
        <p>Поддерживаемые платформы</p>
        <div class="pill-group" style="justify-content: center; margin-top: 10px">
          <template x-for="p in PlatformRegistry.all()" :key="p.name">
            <div class="pill">
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="currentColor"
                :style="{ color: p.colors?.icon }"
              >
                <path :d="p.icon" />
              </svg>
              <span x-text="p.name"></span>
            </div>
          </template>
        </div>
      </footer>
    </main>

    <script type="module">
      import Alpine from "alpinejs";

      const AppConfig = Object.freeze({
        BOT_USERNAME: "ClipperAppBot",
        FETCH_TIMEOUT: 15000,
        PROGRESS_INTERVAL: 100,
        PROGRESS_STEP_MIN: 2,
        PROGRESS_STEP_MAX: 10,
        PROGRESS_LIMIT: 100,
        HISTORY_MAX: 20,
        HISTORY_KEY: "clipper_history",
        SPONSORS_KEY: "clipper_sponsors_v1",
        SPONSOR_TTL_HOURS: 168
      });

      const AppAssets = Object.freeze({
        avatar:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><rect fill=%22%2333333a%22 width=%2248%22 height=%2248%22/></svg>",
        cover:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 88 120%22><rect fill=%22%2333333a%22 width=%2288%22 height=%22120%22/></svg>",
        sponsor:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><rect fill=%22%237c5cff%22 width=%2248%22 height=%2248%22/></svg>",
      });

      class NumberFormatter {
        static formatDuration(seconds) {
          if (!seconds || !Number.isFinite(seconds)) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, "0")}`;
        }

        static formatCompact(num) {
          if (!num || !Number.isFinite(num)) return "0";
          if (num >= 1e6) return `${(num / 1e6).toFixed(1)}M`;
          if (num >= 1e3) return `${(num / 1e3).toFixed(1)}K`;
          return num.toString();
        }
      }

      class UrlValidator {
        static isValid(value) {
          try {
            const url = new URL(value);
            return ["http:", "https:"].includes(url.protocol);
          } catch {
            return false;
          }
        }
      }

      class ErrorHandler {
        static getMessage(error) {
          if (error?.name === "AbortError") return "Превышено время ожидания";
          if (error?.message) return error.message;
          return "Произошла неизвестная ошибка";
        }
      }

      class HistoryStorage {
        static get cloudStorage() {
          return window.Telegram?.WebApp?.CloudStorage;
        }

        static async getAll() {
          try {
            const storage = this.cloudStorage;
            if (!storage) {
              return JSON.parse(localStorage.getItem(AppConfig.HISTORY_KEY)) || [];
            }

            return new Promise((resolve) => {
              storage.getItem(AppConfig.HISTORY_KEY, (err, value) => {
                if (err || !value) return resolve([]);
                try {
                  resolve(JSON.parse(value) || []);
                } catch {
                  resolve([]);
                }
              });
            });
          } catch {
            return [];
          }
        }

        static async add(item) {
          const list = (await this.getAll()).filter((i) => i.id !== item.id);
          list.unshift(item);
          const data = JSON.stringify(list.slice(0, AppConfig.HISTORY_MAX));

          const storage = this.cloudStorage;
          if (!storage) {
            localStorage.setItem(AppConfig.HISTORY_KEY, data);
            return;
          }

          return new Promise((resolve) => {
            storage.setItem(AppConfig.HISTORY_KEY, data, () => resolve());
          });
        }

        static async updateQuality(id, quality) {
          const list = await this.getAll();
          const item = list.find((i) => i.id === id);
          if (!item) return;
          item.quality = quality;
          const data = JSON.stringify(list);

          const storage = this.cloudStorage;
          if (!storage) {
            localStorage.setItem(AppConfig.HISTORY_KEY, data);
            return;
          }

          return new Promise((resolve) => {
            storage.setItem(AppConfig.HISTORY_KEY, data, () => resolve());
          });
        }

        static async clear() {
          const storage = this.cloudStorage;
          if (!storage) {
            localStorage.removeItem(AppConfig.HISTORY_KEY);
            return;
          }

          return new Promise((resolve) => {
            storage.removeItem(AppConfig.HISTORY_KEY, () => resolve());
          });
        }
      }

      class TelegramWebApp {
        static get instance() {
          return window.Telegram?.WebApp;
        }

        static initialize() {
          const app = this.instance;
          if (!app) return;
          app.ready();
          app.disableVerticalSwipes?.();
          app.setHeaderColor?.("#0b0b0f");
          app.setBackgroundColor?.("#0b0b0f");

          const theme = app.themeParams;
          if (theme?.bg_color) {
            document.documentElement.style.setProperty("--bg", theme.bg_color);
          }
          if (theme?.text_color) {
            document.documentElement.style.setProperty("--text", theme.text_color);
          }
          if (theme?.hint_color) {
            document.documentElement.style.setProperty("--muted", theme.hint_color);
          }
        }

        static get startParam() {
          return this.instance?.initDataUnsafe?.start_param || null;
        }

        static get userId() {
          return this.instance?.initDataUnsafe?.user?.id || null;
        }

        static hapticImpact(style = "light") {
          this.instance?.HapticFeedback?.impactOccurred(style);
        }

        static hapticNotification(type) {
          this.instance?.HapticFeedback?.notificationOccurred(type);
        }

        static downloadFile(url, filename) {
          if (!this.instance?.downloadFile) return false;
          this.instance.downloadFile({ url, file_name: filename });
          return true;
        }

        static shareToStory(mediaUrl, text) {
          if (!this.instance?.shareToStory) return false;
          this.instance.shareToStory(mediaUrl, {
            text: text || "",
            widget_link: {
              url: `https://t.me/${AppConfig.BOT_USERNAME}`,
              name: "Clipper",
            },
          });
          return true;
        }

        static openExternalLink(url) {
          if (this.instance?.openLink) this.instance.openLink(url);
          else globalThis.open(url, "_blank", "noopener,noreferrer");
        }

        static openTelegramLink(url) {
          if (this.instance?.openTelegramLink) this.instance.openTelegramLink(url);
          else globalThis.open(url, "_blank", "noopener,noreferrer");
        }

        static shareUrl(url, text) {
          const shareLink = `https://t.me/share/url?url=${encodeURIComponent(
            url
          )}&text=${encodeURIComponent(text || "")}`;
          this.openTelegramLink(shareLink);
          return true;
        }

        static showConfirm(message, callback) {
          if (this.instance?.showConfirm) {
            this.instance.showConfirm(message, callback);
            return;
          }
          callback(confirm(message));
        }
      }

      const SponsorService = {
        sponsors: [
          {
            username: "telegram",
            title: "Telegram",
            photo:
              "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?q=80&w=200&auto=format&fit=crop",
          },
          {
            username: "durov",
            title: "Pavel Durov",
            photo:
              "https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=200&auto=format&fit=crop",
          },
          {
            username: "tiktok",
            title: "TikTok",
            photo:
              "https://images.unsplash.com/photo-1487412912498-0447578fcca8?q=80&w=200&auto=format&fit=crop",
          },
        ],
        getState() {
          const raw = localStorage.getItem(AppConfig.SPONSORS_KEY);
          try {
            return raw ? JSON.parse(raw) : {};
          } catch {
            return {};
          }
        },
        saveState(state) {
          localStorage.setItem(AppConfig.SPONSORS_KEY, JSON.stringify(state));
        },
        markOpened(username) {
          const state = this.getState();
          state[username] = {
            ...state[username],
            openedAt: Date.now(),
          };
          this.saveState(state);
        },
        confirm(username) {
          const state = this.getState();
          const now = Date.now();
          state[username] = {
            ...state[username],
            confirmedAt: now,
          };
          this.saveState(state);
        },
        isConfirmed(username) {
          const state = this.getState();
          const info = state[username];
          if (!info?.confirmedAt) return false;
          const ttl = AppConfig.SPONSOR_TTL_HOURS * 60 * 60 * 1000;
          return Date.now() - info.confirmedAt < ttl;
        },
        canConfirm(username) {
          const state = this.getState();
          const info = state[username];
          if (!info?.openedAt) return false;
          return Date.now() - info.openedAt < 10 * 60 * 1000;
        }
      };

      class VideoPlatform {
        constructor(config) {
          this.name = config.name;
          this.colors = config.colors;
          this.icon = config.icon;
          this.patterns = config.patterns;
          this.stats = config.stats;
          this.authorUrlTemplate = config.authorUrlTemplate;
          this.supportsQuality = config.supportsQuality || false;
          this.qualities = config.qualities || [];
          this._fetch = config._fetch;
          this._extractId = config._extractId;
          this._buildUrlFromId = config._buildUrlFromId;
        }

        match(url) {
          return this.patterns.some((pattern) => pattern.test(url));
        }

        extractId(url) {
          if (this._extractId) return this._extractId(url);
          for (const pattern of this.patterns) {
            const match = url.match(pattern);
            if (match?.[1]) return match[1];
          }
          return null;
        }

        getAuthorUrl(author) {
          if (!this.authorUrlTemplate || !author?.unique_id) return null;
          return this.authorUrlTemplate.replace("{username}", author.unique_id);
        }

        async fetchVideo(url, quality = "hd", externalSignal) {
          const controller = new AbortController();
          const timeoutId = setTimeout(
            () => controller.abort(),
            AppConfig.FETCH_TIMEOUT
          );

          if (externalSignal) {
            if (externalSignal.aborted) controller.abort();
            externalSignal.addEventListener(
              "abort",
              () => controller.abort(),
              { once: true }
            );
          }

          try {
            const q = this.supportsQuality ? quality : "sd";
            const data = await this._fetch(url, controller.signal, q);
            if (!data?.play) throw new Error("Видео недоступно");
            return data;
          } finally {
            clearTimeout(timeoutId);
          }
        }

        getFilename(video, quality) {
          const id = video?.id || Date.now();
          const qualitySuffix = quality ? `_${quality}` : "";
          return `${this.name.toLowerCase()}_${id}${qualitySuffix}.mp4`;
        }

        getShareParam(video, url) {
          const id = video?.id || this.extractId(url);
          if (id) return `${this.name.toLowerCase()}_${id}`;
          const utf8Bytes = new TextEncoder().encode(url);
          const binaryString = String.fromCharCode(...utf8Bytes);
          return btoa(binaryString).replace(/[+/=]/g, (c) => ({ "+": "-", "/": "_" })[c] || "");
        }

        buildUrlFromId(id) {
          return this._buildUrlFromId?.(id) || null;
        }
      }

      class PlatformRegistry {
        static platforms = [];

        static register(config) {
          this.platforms.push(new VideoPlatform(config));
        }

        static detect(url) {
          if (!url) return null;
          return this.platforms.find((p) => p.match(url)) || null;
        }

        static get(name) {
          return this.platforms.find((p) => p.name === name) || null;
        }

        static all() {
          return this.platforms;
        }

        static parseStartParam(param) {
          if (!param || typeof param !== "string") return null;

          const platformMatch = param.match(/^([a-z]+)_(.+)$/i);
          if (platformMatch) {
            const [, platformName, id] = platformMatch;
            const platform = this.platforms.find(
              (p) => p.name.toLowerCase() === platformName.toLowerCase()
            );
            if (!platform) return { error: "unsupported_platform", platformName };
            if (/^\d+$/.test(id)) {
              const url = platform.buildUrlFromId(id);
              if (url) return { platform: platform.name, id, url };
            }
            return { error: "invalid_id", platformName: platform.name };
          }

          if (param.length > 10) {
            let base64 = param.replace(/-/g, "+").replace(/_/g, "/");
            const padLength = (4 - (base64.length % 4)) % 4;
            base64 += "=".repeat(padLength);
            try {
              const decoded = new TextDecoder("utf-8", { fatal: true }).decode(
                Uint8Array.from(atob(base64), (c) => c.charCodeAt(0))
              );
              if (decoded.startsWith("http") && UrlValidator.isValid(decoded)) {
                const platform = this.detect(decoded);
                if (platform) return { platform: platform.name, id: null, url: decoded };
                return { error: "unsupported_platform", url: decoded };
              }
            } catch {}
          }
          return { error: "invalid_format" };
        }
      }

      const TopWidgetData = Object.freeze({
        countries: [
          { code: "ru", name: "Россия" },
          { code: "kz", name: "Казахстан" },
          { code: "ua", name: "Украина" },
          { code: "us", name: "USA" },
          { code: "tr", name: "Türkiye" },
        ],
        videos: {
          TikTok: {
            ru: [
              {
                id: "t1",
                title: "Лучшие переходы недели",
                author: "@visuals",
                views: "1.4M",
                duration: "0:24",
                cover:
                  "https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?q=80&w=400&auto=format&fit=crop",
              },
              {
                id: "t2",
                title: "Город в режиме неона",
                author: "@nightlife",
                views: "948K",
                duration: "0:31",
                cover:
                  "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=400&auto=format&fit=crop",
              },
              {
                id: "t3",
                title: "Новый тренд: slowmo",
                author: "@motion",
                views: "2.1M",
                duration: "0:29",
                cover:
                  "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=400&auto=format&fit=crop",
              },
              {
                id: "t4",
                title: "Утро в мегаполисе",
                author: "@citylife",
                views: "630K",
                duration: "0:20",
                cover:
                  "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?q=80&w=400&auto=format&fit=crop",
              },
              {
                id: "t5",
                title: "Свет, камера, движение",
                author: "@studio",
                views: "1.1M",
                duration: "0:27",
                cover:
                  "https://images.unsplash.com/photo-1487412912498-0447578fcca8?q=80&w=400&auto=format&fit=crop",
              },
              {
                id: "t6",
                title: "Трендовый монтаж",
                author: "@cut",
                views: "712K",
                duration: "0:22",
                cover:
                  "https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=400&auto=format&fit=crop",
              }
            ],
            default: []
          }
        }
      });

      PlatformRegistry.register({
        name: "TikTok",
        colors: {
          primary: "#fe2c55",
          progress: "#ffffff",
          icon: "#ffffff",
          save: "#fe2c55",
          story: "#f7f7f7",
          statsIcon: "#fe2c55",
        },
        icon: "M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64c.29 0 .58.04.88.13V9.4c-.29-.03-.6-.05-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4c-.35-.05-.7-.08-1.04-.1z",
        patterns: [
          /^https?:\/\/(?:www\.)?tiktok\.com\/@[\w.-]+\/video\/(\d+)/i,
          /^https?:\/\/(?:www\.)?tiktok\.com\/t\/([\w-]+)/i,
          /^https?:\/\/vm\.tiktok\.com\/([\w-]+)/i,
          /^https?:\/\/vt\.tiktok\.com\/([\w-]+)/i,
        ],
        authorUrlTemplate: "https://www.tiktok.com/@{username}",
        supportsQuality: true,
        qualities: [
          { key: "hd", label: "HD", param: 1 },
          { key: "sd", label: "SD", param: 0 },
        ],
        stats: [
          {
            key: "play_count",
            label: "Просмотры",
            icon: "M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z",
          },
          {
            key: "digg_count",
            label: "Лайки",
            icon: "M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z",
          },
          {
            key: "comment_count",
            label: "Комменты",
            icon: "M12 20.25c4.97 0 9-3.694 9-8.25s-4.03-8.25-9-8.25S3 7.444 3 12c0 2.104.859 4.023 2.273 5.48.432.447.74 1.04.586 1.641a4.483 4.483 0 0 1-.923 1.785A5.969 5.969 0 0 0 6 21c1.282 0 2.47-.402 3.445-1.087.81.22 1.668.337 2.555.337Z",
          },
          {
            key: "share_count",
            label: "Репосты",
            icon: "M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z",
          },
        ],
        _extractId(url) {
          const match = url.match(/video\/(\d+)/i);
          return match?.[1] || null;
        },
        _buildUrlFromId(id) {
          return `https://www.tiktok.com/@_/video/${id}`;
        },
        async _fetch(url, signal, quality = "hd") {
          if (!url || typeof url !== "string") throw new Error("Вставьте ссылку на видео");

          const trimmedUrl = url.trim();
          if (!trimmedUrl) throw new Error("Ссылка не может быть пустой");

          let response;
          try {
            response = await fetch("https://www.tikwm.com/api/", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: new URLSearchParams({ url: trimmedUrl, hd: quality === "hd" ? 1 : 0 }),
              signal,
            });
          } catch (err) {
            if (err.name === "AbortError") throw err;
            throw new Error("Ошибка сети. Проверьте подключение к интернету");
          }

          if (!response.ok) throw new Error(`Сервер недоступен (${response.status})`);

          let json;
          try {
            json = await response.json();
          } catch {
            throw new Error("Ошибка обработки ответа сервера");
          }

          if (json.code !== 0) throw new Error(json.msg || "Не удалось получить данные");

          const data = json.data;
          if (!data?.play) throw new Error("Ссылка на видео недоступна");

          data.hdPlay = data.hdplay || null;
          data.hasHD = Boolean(data.hdplay);
          data.currentQuality = quality === "hd" && data.hasHD ? "hd" : "sd";

          return data;
        },
      });

      globalThis.NumberFormatter = NumberFormatter;
      globalThis.PlatformRegistry = PlatformRegistry;
      globalThis.TelegramWebApp = TelegramWebApp;
      globalThis.AppAssets = AppAssets;

      Alpine.data("ClipperApp", () => ({
        url: "",
        platform: null,
        isLoading: false,
        progress: 0,
        video: null,
        error: null,
        history: [],
        selectedQuality: "hd",
        isChangingQuality: false,
        isSaving: false,
        progressTimer: null,
        downloadAbortController: null,
        sponsorsList: SponsorService.sponsors,
        topPlatform: PlatformRegistry.all()[0]?.name || "TikTok",
        topCountry: TopWidgetData.countries[0]?.code || "ru",
        topVideos: [],

        get statusText() {
          if (this.isLoading) return "Загрузка видео...";
          if (this.error) return "Попробуйте другую ссылку";
          if (this.video) return "Видео готово к сохранению";
          if (this.platform) return this.platform.name;
          return "Сохраняйте видео легко и быстро";
        },

        get loadingText() {
          if (this.progress < 30) return "Подключение к серверу...";
          if (this.progress < 60) return "Получение видео...";
          if (this.progress < 90) return "Обработка данных...";
          return "Почти готово...";
        },

        get visibleStats() {
          if (!this.platform?.stats || !this.video) return [];
          return this.platform.stats.filter(
            (s) => this.video[s.key] != null && this.video[s.key] > 0
          );
        },

        get hasMultipleQualities() {
          if (!this.platform?.supportsQuality) return false;
          if (!this.video?.hasHD) return false;
          return this.video.hdPlay && this.video.hdPlay !== this.video.play;
        },

        get availableQualities() {
          if (!this.platform?.qualities) return [];
          if (!this.video) return this.platform.qualities;
          if (!this.video.hasHD) return this.platform.qualities.filter((q) => q.key === "sd");
          return this.platform.qualities;
        },

        get currentQualityLabel() {
          if (!this.video) return "";
          return this.selectedQuality === "hd" && this.video.hasHD ? "HD" : "SD";
        },

        get currentVideoUrl() {
          if (!this.video?.play) return null;
          if (this.selectedQuality === "hd" && this.video.hdPlay) return this.video.hdPlay;
          return this.video.play;
        },

        get topCountries() {
          return TopWidgetData.countries;
        },

        get unconfirmedSponsors() {
          return this.sponsorsList.filter((s) => !SponsorService.isConfirmed(s.username));
        },

        init() {
          TelegramWebApp.initialize();
          this.updateTopVideos();
          HistoryStorage.getAll().then((list) => (this.history = list));
          this.handleStartParam();
        },

        updateTopVideos() {
          const platform = TopWidgetData.videos[this.topPlatform];
          const list =
            platform?.[this.topCountry] ||
            platform?.default ||
            TopWidgetData.videos.TikTok.ru;
          this.topVideos = list.slice(0, 6);
        },

        selectTopPlatform(name) {
          this.topPlatform = name;
          this.updateTopVideos();
        },

        detect() {
          this.error = null;
          if (!this.url?.trim()) {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
            return;
          }

          if (!UrlValidator.isValid(this.url)) {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
            return;
          }

          const detected = PlatformRegistry.detect(this.url);
          if (detected) {
            if (this.platform?.name !== detected.name) this.selectedQuality = "hd";
            this.platform = detected;
            TelegramWebApp.hapticImpact("light");
          } else {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
          }
        },

        clear() {
          this.url = "";
          this.platform = null;
          this.video = null;
          this.error = null;
          this.selectedQuality = "hd";
          TelegramWebApp.hapticImpact("light");
        },

        setError(message) {
          this.error = message;
          TelegramWebApp.hapticNotification("error");
        },

        startProgress() {
          this.stopProgress();
          this.progressTimer = setInterval(() => {
            const step =
              Math.floor(Math.random() * (AppConfig.PROGRESS_STEP_MAX - AppConfig.PROGRESS_STEP_MIN + 1)) +
              AppConfig.PROGRESS_STEP_MIN;
            this.progress = Math.min(this.progress + step, AppConfig.PROGRESS_LIMIT);
          }, AppConfig.PROGRESS_INTERVAL);
        },

        stopProgress() {
          if (this.progressTimer) {
            clearInterval(this.progressTimer);
            this.progressTimer = null;
          }
        },

        async selectQuality(quality) {
          if (!this.video || !this.platform) return;
          if (quality === "hd" && !this.video.hasHD) return;
          if (this.selectedQuality === quality || this.isChangingQuality) return;

          this.isChangingQuality = true;
          const videoEl = document.querySelector("video");
          const wasPlaying = videoEl && !videoEl.paused;
          const currentTime = videoEl?.currentTime || 0;
          const oldQuality = this.selectedQuality;

          this.selectedQuality = quality;
          Telegram.WebApp.hapticImpact("light");

          await this.$nextTick();

          if (videoEl) {
            try {
              videoEl.load();

              await new Promise((resolve, reject) => {
                const onLoaded = () => {
                  videoEl.removeEventListener("loadeddata", onLoaded);
                  videoEl.removeEventListener("error", onError);
                  resolve();
                };
                const onError = () => {
                  videoEl.removeEventListener("loadeddata", onLoaded);
                  videoEl.removeEventListener("error", onError);
                  reject(new Error("Ошибка загрузки видео"));
                };

                videoEl.addEventListener("loadeddata", onLoaded);
                videoEl.addEventListener("error", onError);
                setTimeout(resolve, 3000);
              });

              videoEl.currentTime = currentTime;

              if (wasPlaying) {
                try {
                  await videoEl.play();
                } catch {}
              }
            } catch {
              this.selectedQuality = oldQuality;
            }
          }

          await this.updateHistoryQuality();
          this.isChangingQuality = false;
        },

        async updateHistoryQuality() {
          if (!this.video || !this.platform) return;
          const historyId = this.video.id || `${this.platform.name}_${Date.now()}`;
          await HistoryStorage.updateQuality(historyId, this.selectedQuality);
          this.history = await HistoryStorage.getAll();
        },

        async saveToHistory() {
          if (!this.video || !this.platform) return;
          await HistoryStorage.add({
            id: this.video.id || `${this.platform.name}_${Date.now()}`,
            cover: this.video.cover,
            author:
              this.video.author?.nickname ||
              this.video.author?.unique_id ||
              "Неизвестный автор",
            url: this.url,
            platform: this.platform.name,
            quality: this.selectedQuality,
          });
          this.history = await HistoryStorage.getAll();
        },

        hasSponsorAccess() {
          return this.unconfirmedSponsors.length === 0;
        },

        canConfirmSponsor(username) {
          return SponsorService.canConfirm(username);
        },

        isSponsorConfirmed(username) {
          return SponsorService.isConfirmed(username);
        },

        confirmSponsor(username) {
          if (!SponsorService.canConfirm(username)) {
            this.setError("Сначала откройте канал спонсора");
            return;
          }
          SponsorService.confirm(username);
          TelegramWebApp.hapticNotification("success");
        },

        openSponsor(username) {
          SponsorService.markOpened(username);
          TelegramWebApp.hapticImpact("light");
          TelegramWebApp.openTelegramLink(`https://t.me/${username}`);
        },

        handleStartParam() {
          const param = TelegramWebApp.startParam;
          if (!param) return;

          const parsed = PlatformRegistry.parseStartParam(param);

          if (!parsed || parsed.error) {
            switch (parsed?.error) {
              case "unsupported_platform":
                this.setError(
                  `Платформа "${parsed.platformName || "неизвестная"}" не поддерживается`
                );
                break;
              case "invalid_id":
                this.setError("Неверный идентификатор видео");
                break;
              default:
                this.setError("Неверная ссылка");
                break;
            }
            return;
          }

          const platform = PlatformRegistry.get(parsed.platform);
          if (!platform) {
            this.setError("Платформа не поддерживается");
            return;
          }

          const url = parsed.url || platform.buildUrlFromId(parsed.id);
          if (url) {
            this.url = url;
            this.platform = platform;
            this.$nextTick(() => this.download());
          } else {
            this.setError("Не удалось восстановить ссылку");
          }
        },

        async download() {
          if (!this.platform || this.isLoading || !this.url?.trim()) return;

          if (!this.hasSponsorAccess()) {
            this.setError("Подпишитесь на спонсоров для загрузки видео");
            return;
          }

          if (this.downloadAbortController) {
            this.downloadAbortController.abort();
          }
          this.downloadAbortController = new AbortController();

          this.isLoading = true;
          this.progress = 0;
          this.error = null;
          this.video = null;
          TelegramWebApp.hapticImpact("medium");

          this.startProgress();

          try {
            this.video = await this.platform.fetchVideo(
              this.url,
              this.selectedQuality,
              this.downloadAbortController.signal
            );
            this.progress = 100;

            if (!this.video.hasHD) {
              this.selectedQuality = "sd";
            } else if (this.video.currentQuality) {
              this.selectedQuality = this.video.currentQuality;
            }

            await this.saveToHistory();
            TelegramWebApp.hapticNotification("success");
          } catch (err) {
            if (err.name !== "AbortError") {
              this.setError(ErrorHandler.getMessage(err));
            }
          } finally {
            this.stopProgress();
            this.isLoading = false;
            this.downloadAbortController = null;
          }
        },

        saveVideo() {
          if (!this.video || !this.platform || this.isSaving) return;

          const videoUrl = this.currentVideoUrl;
          if (!videoUrl) return;

          this.isSaving = true;

          try {
            const filename = this.platform.getFilename(
              this.video,
              this.selectedQuality
            );
            const success = TelegramWebApp.downloadFile(videoUrl, filename);
            if (success) TelegramWebApp.hapticNotification("success");
            else this.setError("Скачивание доступно только в мобильном Telegram");
          } finally {
            setTimeout(() => {
              this.isSaving = false;
            }, 500);
          }
        },

        shareStory() {
          if (!this.video || !this.platform) return;

          const videoUrl = this.currentVideoUrl;
          if (!videoUrl) {
            this.setError("Видео недоступно");
            return;
          }

          let text = `Сохранено через @${AppConfig.BOT_USERNAME}`;
          if (this.video.title?.trim()) {
            text = `${this.video.title.trim()}\n\n${text}`;
          }

          const success = TelegramWebApp.shareToStory(videoUrl, text);
          if (success) TelegramWebApp.hapticNotification("success");
          else this.setError("Истории доступны только в мобильном Telegram");
        },

        shareLink() {
          if (!this.platform || !this.video) {
            this.setError("Нет данных для ссылки");
            return;
          }

          const param = this.platform.getShareParam(this.video, this.url);
          if (!param) {
            this.setError("Не удалось создать ссылку");
            return;
          }

          const shareUrl = `https://t.me/${AppConfig.BOT_USERNAME}/?startapp=${param}`;
          const shareText = `Сохрани видео через @${AppConfig.BOT_USERNAME}`;

          TelegramWebApp.shareUrl(shareUrl, shareText);
          TelegramWebApp.hapticNotification("success");
        },

        openAuthorProfile() {
          TelegramWebApp.hapticImpact("light");
          if (!this.platform || !this.video?.author) return;

          const url = this.platform.getAuthorUrl(this.video.author);
          if (url) TelegramWebApp.openExternalLink(url);
        },

        loadFromHistory(item) {
          if (!item?.url || !item?.platform) {
            this.setError("Некорректные данные");
            return;
          }

          this.url = item.url;
          this.platform = PlatformRegistry.get(item.platform);

          const validQualities = ["hd", "sd"];
          if (
            item.quality &&
            typeof item.quality === "string" &&
            validQualities.includes(item.quality.toLowerCase())
          ) {
            this.selectedQuality = item.quality.toLowerCase();
          } else {
            this.selectedQuality = "hd";
          }

          if (this.platform) {
            TelegramWebApp.hapticImpact("light");
            this.download();
          } else {
            this.setError("Платформа не поддерживается");
          }
        },

        clearHistory() {
          TelegramWebApp.showConfirm(
            "Вы уверены, что хотите очистить историю?",
            async (confirmed) => {
              if (confirmed) {
                await HistoryStorage.clear();
                this.history = [];
                TelegramWebApp.hapticImpact("medium");
              }
            }
          );
        },
      }));

      Alpine.start();
    </script>
  </body>
</html>